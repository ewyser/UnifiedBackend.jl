<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · UnifiedBackend.jl</title><meta name="title" content="API Reference · UnifiedBackend.jl"/><meta property="og:title" content="API Reference · UnifiedBackend.jl"/><meta property="twitter:title" content="API Reference · UnifiedBackend.jl"/><meta name="description" content="Documentation for UnifiedBackend.jl."/><meta property="og:description" content="Documentation for UnifiedBackend.jl."/><meta property="twitter:description" content="Documentation for UnifiedBackend.jl."/><meta property="og:url" content="https://ewyser.github.io/UnifiedBackend.jl/api/"/><meta property="twitter:url" content="https://ewyser.github.io/UnifiedBackend.jl/api/"/><link rel="canonical" href="https://ewyser.github.io/UnifiedBackend.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">UnifiedBackend.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Public-API"><span>Public API</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../extensions/">Extensions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ewyser/UnifiedBackend.jl.git" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ewyser/UnifiedBackend.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h2><h3 id="Backend-Access"><a class="docs-heading-anchor" href="#Backend-Access">Backend Access</a><a id="Backend-Access-1"></a><a class="docs-heading-anchor-permalink" href="#Backend-Access" title="Permalink"></a></h3><article><details class="docstring"><summary id="UnifiedBackend.backend"><a class="docstring-binding" href="#UnifiedBackend.backend"><code>UnifiedBackend.backend</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">backend() -&gt; Backend</code></pre><p>Get the global backend configuration instance.</p><p>Returns the singleton <code>Backend</code> instance that manages the execution platforms and library registry for the entire UnifiedBackend session.</p><p><strong>Returns</strong></p><ul><li><code>Backend</code>: The global backend configuration object</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using UnifiedBackend

# Access the global backend
b = backend()

# Inspect available platforms
println(b.exec.functional)

# Access host devices
println(keys(b.exec.host))

# Access device (GPU) configurations
println(keys(b.exec.device))</code></pre><p><strong>See Also</strong></p><ul><li><a href="#UnifiedBackend.Backend"><code>Backend</code></a>: Backend configuration structure</li><li><a href="#UnifiedBackend.ExecutionPlatforms"><code>ExecutionPlatforms</code></a>: Execution platform registry</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ewyser/UnifiedBackend.jl/blob/6a83ec619b17657f684e20893dc53675fa248a07/src/UnifiedBackend.jl#L108-L139">source</a></section></details></article><article><details class="docstring"><summary id="UnifiedBackend.Backend"><a class="docstring-binding" href="#UnifiedBackend.Backend"><code>UnifiedBackend.Backend</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Backend</code></pre><p>Immutable struct representing the unified backend system configuration.</p><p>This is the top-level configuration structure that manages the entire UnifiedBackend session. It provides an immutable container for library tracking and execution platform management. The structure itself is immutable, but the contained dictionaries and <code>ExecutionPlatforms</code> are mutable, allowing runtime updates to device configurations.</p><p><strong>Fields</strong></p><ul><li><code>lib::Dict{String,Any}</code>: Library and module registry for loaded components and file tracking</li><li><code>exec::ExecutionPlatforms</code>: Mutable execution platform configuration for host and device backends</li></ul><p><strong>Design Pattern</strong></p><p>The <code>Backend</code> struct uses an immutable wrapper around mutable data pattern:</p><ul><li>The struct itself cannot be reassigned, ensuring singleton integrity</li><li>The <code>lib</code> and <code>exec</code> fields can be mutated internally for runtime configuration updates</li><li>This provides both safety and flexibility</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using UnifiedBackend

# Access the global backend instance
b = backend()

# Inspect library registry (populated by module loading system)
println(keys(b.lib))

# Access execution platforms
println(b.exec.functional)

# Get CPU devices
cpus = b.exec.host
for (dev_id, config) in cpus
    println(&quot;$dev_id: $(config[:name])&quot;)
end

# Create a custom backend (typically not needed - use global instance)
custom_backend = Backend(
    lib = Dict{String,Any}(&quot;custom&quot; =&gt; &quot;data&quot;),
    exec = ExecutionPlatforms()
)</code></pre><p><strong>Global Instance</strong></p><p>UnifiedBackend maintains a global singleton instance accessed via <a href="#UnifiedBackend.backend"><code>backend()</code></a>:</p><pre><code class="language-julia hljs">b = backend()
devices = select_execution_backend(b.exec, &quot;host&quot;)</code></pre><p><strong>See Also</strong></p><ul><li><a href="#UnifiedBackend.ExecutionPlatforms"><code>ExecutionPlatforms</code></a>: Execution platform registry structure</li><li><a href="#UnifiedBackend.backend"><code>backend</code></a>: Accessor for the global <code>Backend</code> instance</li><li><a href="#UnifiedBackend.select_execution_backend"><code>select_execution_backend</code></a>: Device selection function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ewyser/UnifiedBackend.jl/blob/6a83ec619b17657f684e20893dc53675fa248a07/src/boot/needs/types/concrete/types.jl#L67-L130">source</a></section></details></article><article><details class="docstring"><summary id="UnifiedBackend.ExecutionPlatforms"><a class="docstring-binding" href="#UnifiedBackend.ExecutionPlatforms"><code>UnifiedBackend.ExecutionPlatforms</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ExecutionPlatforms</code></pre><p>Mutable struct representing the execution platform configuration for host (CPU) and device (GPU).</p><p>This structure maintains the registry of available computational devices and their configurations. It is designed to be populated at runtime as backends are initialized and devices are detected.</p><p><strong>Fields</strong></p><ul><li><code>functional::Vector{String}</code>: List of successfully initialized execution platforms with status messages</li><li><code>host::Dict{Symbol,Dict{Symbol,Any}}</code>: Host (CPU) device configurations, indexed by device symbols (<code>:dev1</code>, <code>:dev2</code>, etc.)</li><li><code>device::Dict{Symbol,Dict{Symbol,Any}}</code>: Accelerator (GPU) device configurations, indexed by device symbols</li></ul><p><strong>Host/Device Configuration Keys</strong></p><p>Each device dictionary contains:</p><ul><li><code>:host</code> or <code>:dev</code>: Device category (&quot;cpu&quot; or &quot;gpu&quot;)</li><li><code>:platform</code>: Platform identifier (<code>:CPU</code>, <code>:CUDA</code>, <code>:ROCm</code>, etc.)</li><li><code>:brand</code>: Manufacturer brand (e.g., &quot;Intel&quot;, &quot;AMD&quot;, &quot;NVIDIA&quot;)</li><li><code>:name</code>: Specific device model name</li><li><code>:Backend</code>: KernelAbstractions backend instance</li><li><code>:wrapper</code>: Array wrapper type (<code>Array</code>, <code>CuArray</code>, <code>ROCArray</code>, etc.)</li><li><code>:handle</code>: Device handle for direct device manipulation</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using UnifiedBackend

# Create a new execution platforms registry
exec = ExecutionPlatforms()

# Populate with CPU backend
add_backend!(exec, Val(:x86_64))

# Check what&#39;s available
println(exec.functional)  # [&quot;Available execution platform(s):&quot;, &quot;✓ Intel x86_64&quot;]

# Access first CPU device configuration
cpu_dev = exec.host[:dev1]
println(cpu_dev[:name])      # &quot;Intel(R) Core(TM) i9-9900K...&quot;
println(cpu_dev[:platform])  # :CPU
println(cpu_dev[:Backend])   # CPU()

# After loading CUDA
using CUDA
# GPU devices automatically registered in exec.device
gpu_dev = exec.device[:dev1]
println(gpu_dev[:brand])     # &quot;NVIDIA&quot;</code></pre><p><strong>See Also</strong></p><ul><li><a href="#UnifiedBackend.Backend"><code>Backend</code></a>: Top-level configuration containing an <code>ExecutionPlatforms</code> instance</li><li><a href="#UnifiedBackend.add_backend!"><code>add_backend!</code></a>: Function to populate this structure with available devices</li><li><a href="#UnifiedBackend.select_execution_backend"><code>select_execution_backend</code></a>: Select devices from this registry</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ewyser/UnifiedBackend.jl/blob/6a83ec619b17657f684e20893dc53675fa248a07/src/boot/needs/types/concrete/types.jl#L3-L60">source</a></section></details></article><h3 id="Device-Selection"><a class="docs-heading-anchor" href="#Device-Selection">Device Selection</a><a id="Device-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Device-Selection" title="Permalink"></a></h3><article><details class="docstring"><summary id="UnifiedBackend.select_execution_backend"><a class="docstring-binding" href="#UnifiedBackend.select_execution_backend"><code>UnifiedBackend.select_execution_backend</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">select_execution_backend(
    bckd::ExecutionPlatforms, 
    select::String=&quot;host&quot;; 
    prompt::Bool=false, 
    distributed::Bool=false
) -&gt; NamedTuple</code></pre><p>High-level function to select execution backend (CPU or GPU) with automatic fallback.</p><p>This is the primary interface for backend selection in UnifiedBackend. It provides a simple string-based API to choose between host (CPU) and device (GPU) execution, with automatic fallback to CPU if no GPU is available.</p><p><strong>Arguments</strong></p><ul><li><code>bckd::ExecutionPlatforms</code>: The execution platform registry</li><li><code>select::String=&quot;host&quot;</code>: Backend type - <code>&quot;host&quot;</code> for CPU, <code>&quot;device&quot;</code> for GPU</li><li><code>prompt::Bool=false</code>: Enable interactive device selection menu</li><li><code>distributed::Bool=false</code>: Enable multi-device selection</li></ul><p><strong>Selection Modes</strong></p><p>Three modes available via keyword arguments:</p><ol><li><p><strong>Default mode</strong> (<code>prompt=false, distributed=false</code>):</p><ul><li>Returns first available device</li><li>No user interaction</li><li>Best for scripts and non-interactive use</li></ul></li><li><p><strong>Interactive mode</strong> (<code>prompt=true</code>):</p><ul><li>Shows radio menu for single device selection</li><li>User chooses one device from list</li><li>Ideal for targeting specific hardware</li></ul></li><li><p><strong>Distributed mode</strong> (<code>distributed=true</code>):</p><ul><li>Shows multi-select checkbox menu</li><li>User chooses multiple devices</li><li>For parallel/distributed computations</li></ul></li></ol><p><strong>Returns</strong></p><p><code>NamedTuple</code> of device configurations. Structure depends on selection:</p><ul><li>Single device: <code>(dev1 = Dict(...),)</code></li><li>Multiple devices: <code>(dev1 = Dict(...), dev2 = Dict(...), ...)</code></li></ul><p><strong>GPU Fallback Behavior</strong></p><p>When <code>select=&quot;device&quot;</code>:</p><ul><li>If GPUs are available → returns selected GPU(s)</li><li>If no GPUs found → automatically falls back to CPU</li><li>Logs the fallback for user awareness</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using UnifiedBackend

b = backend()

# === CPU Examples ===

# Default: first CPU core
cpu = select_execution_backend(b.exec, &quot;host&quot;)

# Interactive: choose specific core
cpu = select_execution_backend(b.exec, &quot;host&quot;, prompt=true)

# Distributed: select multiple cores
cpus = select_execution_backend(b.exec, &quot;host&quot;, distributed=true)

# === GPU Examples ===

using CUDA  # or AMDGPU

# Default: first GPU
gpu = select_execution_backend(b.exec, &quot;device&quot;)

# Interactive: choose specific GPU (multi-GPU systems)
gpu = select_execution_backend(b.exec, &quot;device&quot;, prompt=true)

# Multi-GPU computation
gpus = select_execution_backend(b.exec, &quot;device&quot;, distributed=true)

# === Practical Usage ===

# Select backend and use in computation
devices = select_execution_backend(b.exec, &quot;device&quot;)
backend_instance = devices.dev1[:Backend]
array_type = devices.dev1[:wrapper]

# Create array on selected backend
data = array_type(rand(1000, 1000))</code></pre><p><strong>Error Handling</strong></p><p>Throws <code>ArgumentError</code> if <code>select</code> is not <code>&quot;host&quot;</code> or <code>&quot;device&quot;</code>.</p><p><strong>Logging</strong></p><p>Logs selection via <code>@info</code>:</p><ul><li>&quot;Using CPU backend (default mode)&quot;</li><li>&quot;Using GPU backend (interactive mode)&quot;</li><li>&quot;No GPU available, falling back to CPU backend&quot;</li></ul><p><strong>See Also</strong></p><ul><li><a href="#UnifiedBackend.get_host"><code>get_host</code></a>: Direct CPU device selection</li><li><a href="#UnifiedBackend.get_device"><code>get_device</code></a>: Direct GPU device selection</li><li><a href="#UnifiedBackend.ExecutionPlatforms"><code>ExecutionPlatforms</code></a>: Device registry structure</li><li><a href="#UnifiedBackend.Backend"><code>Backend</code></a>: Top-level configuration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ewyser/UnifiedBackend.jl/blob/6a83ec619b17657f684e20893dc53675fa248a07/src/home/api/device_selection.jl#L174-L286">source</a></section></details></article><article><details class="docstring"><summary id="UnifiedBackend.get_host"><a class="docstring-binding" href="#UnifiedBackend.get_host"><code>UnifiedBackend.get_host</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_host(bckd::ExecutionPlatforms; prompt::Bool=false, distributed::Bool=false) -&gt; NamedTuple</code></pre><p>Select and return host (CPU) execution device(s) from the available configurations.</p><p>This function provides three selection modes:</p><ul><li><strong>Default</strong>: Returns the first CPU device (<code>:dev1</code>)</li><li><strong>Interactive</strong> (<code>prompt=true</code>): Shows a radio menu to select a single device</li><li><strong>Distributed</strong> (<code>distributed=true</code>): Shows a multi-select menu for multiple devices</li></ul><p><strong>Arguments</strong></p><ul><li><code>bckd::ExecutionPlatforms</code>: The execution platform registry containing host devices</li><li><code>prompt::Bool=false</code>: Enable interactive single-device selection</li><li><code>distributed::Bool=false</code>: Enable multi-device selection</li></ul><p><strong>Returns</strong></p><p><code>NamedTuple</code> where:</p><ul><li>Keys are device symbols (<code>:dev1</code>, <code>:dev2</code>, etc.)</li><li>Values are device configuration dictionaries</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using UnifiedBackend

b = backend()

# Get first CPU device (default)
cpu = get_host(b.exec)
# (dev1 = Dict(:name =&gt; &quot;Intel...&quot;, :platform =&gt; :CPU, ...),)

# Interactive selection - shows menu
cpu = get_host(b.exec, prompt=true)

# Multi-device selection - shows checkboxes
cpus = get_host(b.exec, distributed=true)
# (dev1 = Dict(...), dev3 = Dict(...), dev5 = Dict(...),)

# Access device properties
println(cpu.dev1[:name])     # &quot;Intel(R) Core(TM) i9-9900K...&quot;
println(cpu.dev1[:Backend])  # CPU()</code></pre><p><strong>Interactive Menus</strong></p><p>When <code>prompt=true</code> or <code>distributed=true</code>, displays terminal menus using REPL.TerminalMenus:</p><ul><li>Use arrow keys to navigate</li><li>Press Enter to confirm (radio menu)</li><li>Use Space to toggle, Enter to confirm (multi-select menu)</li></ul><p><strong>See Also</strong></p><ul><li><a href="#UnifiedBackend.get_device"><code>get_device</code></a>: GPU device selection</li><li><a href="#UnifiedBackend.select_execution_backend"><code>select_execution_backend</code></a>: High-level backend selection</li><li><a href="#UnifiedBackend.ExecutionPlatforms"><code>ExecutionPlatforms</code></a>: Device registry structure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ewyser/UnifiedBackend.jl/blob/6a83ec619b17657f684e20893dc53675fa248a07/src/home/api/device_selection.jl#L3-L60">source</a></section></details></article><article><details class="docstring"><summary id="UnifiedBackend.get_device"><a class="docstring-binding" href="#UnifiedBackend.get_device"><code>UnifiedBackend.get_device</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_device(bckd::ExecutionPlatforms; prompt::Bool=false, distributed::Bool=false) -&gt; NamedTuple</code></pre><p>Select and return accelerator (GPU) execution device(s) from the available configurations.</p><p>This function provides three selection modes for GPU devices:</p><ul><li><strong>Default</strong>: Returns the first GPU device</li><li><strong>Interactive</strong> (<code>prompt=true</code>): Shows a radio menu to select a specific GPU</li><li><strong>Distributed</strong> (<code>distributed=true</code>): Shows a multi-select menu for multiple GPUs</li></ul><p><strong>Arguments</strong></p><ul><li><code>bckd::ExecutionPlatforms</code>: The execution platform registry containing device (GPU) configurations</li><li><code>prompt::Bool=false</code>: Enable interactive single-device selection</li><li><code>distributed::Bool=false</code>: Enable multi-device selection</li></ul><p><strong>Returns</strong></p><p><code>NamedTuple</code> where:</p><ul><li>Keys are device symbols (<code>:dev1</code>, <code>:dev2</code>, etc.)</li><li>Values are GPU configuration dictionaries</li></ul><p><strong>GPU Configuration</strong></p><p>Each GPU device contains:</p><ul><li><code>:dev</code>: &quot;gpu&quot;</li><li><code>:platform</code>: <code>:CUDA</code>, <code>:ROCm</code>, etc.</li><li><code>:brand</code>: &quot;NVIDIA&quot;, &quot;AMD&quot;, etc.</li><li><code>:name</code>: Full GPU model name</li><li><code>:Backend</code>: KernelAbstractions backend (<code>CUDABackend()</code>, <code>ROCBackend()</code>)</li><li><code>:wrapper</code>: Array type (<code>CuArray</code>, <code>ROCArray</code>)</li><li><code>:handle</code>: Native device handle (<code>CuDevice</code>, <code>HIPDevice</code>)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using UnifiedBackend, CUDA

b = backend()

# Get first GPU (default)
gpu = get_device(b.exec)
# (dev1 = Dict(:name =&gt; &quot;NVIDIA GeForce RTX 3090&quot;, :platform =&gt; :CUDA, ...),)

# Interactive selection
gpu = get_device(b.exec, prompt=true)

# Multi-GPU selection
gpus = get_device(b.exec, distributed=true)
# (dev1 = Dict(...), dev2 = Dict(...),)

# Access GPU properties
println(gpu.dev1[:name])      # &quot;NVIDIA GeForce RTX 3090&quot;
println(gpu.dev1[:platform])  # :CUDA
println(gpu.dev1[:Backend])   # CUDABackend()
println(gpu.dev1[:wrapper])   # CuArray

# Use device handle for manual control
CUDA.device!(gpu.dev1[:handle])</code></pre><p><strong>Requirements</strong></p><p>GPU devices are only available after loading the appropriate package:</p><ul><li><strong>NVIDIA</strong>: <code>using CUDA</code></li><li><strong>AMD</strong>: <code>using AMDGPU</code></li></ul><p>If no GPUs are registered, this function will error. Use <a href="#UnifiedBackend.select_execution_backend"><code>select_execution_backend</code></a> for automatic fallback to CPU.</p><p><strong>See Also</strong></p><ul><li><a href="#UnifiedBackend.get_host"><code>get_host</code></a>: CPU device selection</li><li><a href="#UnifiedBackend.select_execution_backend"><code>select_execution_backend</code></a>: High-level backend selection with fallback</li><li><a href="#UnifiedBackend.ExecutionPlatforms"><code>ExecutionPlatforms</code></a>: Device registry structure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ewyser/UnifiedBackend.jl/blob/6a83ec619b17657f684e20893dc53675fa248a07/src/home/api/device_selection.jl#L79-L154">source</a></section></details></article><h3 id="Backend-Setup"><a class="docs-heading-anchor" href="#Backend-Setup">Backend Setup</a><a id="Backend-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Backend-Setup" title="Permalink"></a></h3><article><details class="docstring"><summary id="UnifiedBackend.add_backend!"><a class="docstring-binding" href="#UnifiedBackend.add_backend!"><code>UnifiedBackend.add_backend!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">add_backend!(bckd::ExecutionPlatforms, ::Val{ARCH}) where ARCH -&gt; Nothing</code></pre><p>Initialize and populate the execution platform registry with host (CPU) backend configurations.</p><p>This generic implementation works for any CPU architecture by checking which backend in <code>list_host_backend()</code> is functional for the current system. The architecture-specific behavior is determined by the <code>:functional</code> flag in each backend configuration.</p><p>To add support for a new architecture, simply add an entry to <code>list_host_backend()</code>.</p><p><strong>Arguments</strong></p><ul><li><code>bckd::ExecutionPlatforms</code>: The execution platforms registry to populate</li><li><code>::Val{ARCH}</code>: Architecture specification (e.g., <code>Val(:x86_64)</code>, <code>Val(:aarch64)</code>)</li></ul><p><strong>Behavior</strong></p><ol><li>Queries system CPU information via <code>Sys.cpu_info()</code></li><li>Matches detected CPU brand against supported backends</li><li>Creates a device entry for each logical CPU core</li><li>Updates the <code>functional</code> status log</li><li>Logs initialization status via <code>@info</code></li></ol><p><strong>Device Configuration</strong></p><p>Each registered device receives:</p><ul><li><code>:host</code>: &quot;cpu&quot;</li><li><code>:platform</code>: <code>:CPU</code></li><li><code>:brand</code>: Detected manufacturer (e.g., &quot;Intel(R)&quot;, &quot;AMD&quot;, &quot;Apple&quot;)</li><li><code>:name</code>: Full CPU model string</li><li><code>:Backend</code>: KernelAbstractions <code>CPU()</code> backend</li><li><code>:wrapper</code>: <code>Array</code> type for computations</li><li><code>:handle</code>: <code>nothing</code> (CPUs don&#39;t require device handles)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using UnifiedBackend

# Get the global backend
b = backend()

# Initialize for current architecture (usually automatic)
add_backend!(b.exec, Val(Sys.ARCH))

# Inspect registered devices
for (dev_id, config) in b.exec.host
    println(&quot;$dev_id: $(config[:name])&quot;)
end
# Output:
# dev1: Intel(R) Core(TM) i9-9900K CPU @ 3.60GHz
# dev2: Intel(R) Core(TM) i9-9900K CPU @ 3.60GHz
# ... (one per logical core)</code></pre><p><strong>Errors</strong></p><p>Throws <code>ErrorException</code> if CPU model information cannot be retrieved from the system.</p><p><strong>See Also</strong></p><ul><li><a href="#UnifiedBackend.ExecutionPlatforms"><code>ExecutionPlatforms</code></a>: The structure being populated</li><li><a href="#UnifiedBackend.list_host_backend"><code>list_host_backend</code></a>: Backend configuration specifications</li><li><a href="#UnifiedBackend.list_cpu_devices"><code>list_cpu_devices</code></a>: CPU device enumeration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ewyser/UnifiedBackend.jl/blob/6a83ec619b17657f684e20893dc53675fa248a07/src/home/api/backend_setup.jl#L88-L153">source</a></section></details></article><article><details class="docstring"><summary id="UnifiedBackend.list_host_backend"><a class="docstring-binding" href="#UnifiedBackend.list_host_backend"><code>UnifiedBackend.list_host_backend</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">list_host_backend() -&gt; Dict{Symbol, Dict{Symbol, Any}}</code></pre><p>Return a dictionary of supported host (CPU) backend configurations.</p><p>This function provides the hardcoded specifications for supported CPU architectures, including their KernelAbstractions backend, supported brands, and functional status based on the current system architecture.</p><p><strong>Returns</strong></p><p>Dictionary mapping architecture symbols to configuration dictionaries:</p><ul><li><code>:x86_64</code>: Intel and AMD x86-64 processors</li><li><code>:aarch64</code>: ARM64 processors (Apple Silicon, ARM servers)</li></ul><p>Each configuration contains:</p><ul><li><code>:host</code>: Device category (&quot;cpu&quot;)</li><li><code>:Backend</code>: KernelAbstractions CPU backend instance</li><li><code>:brand</code>: Array of supported manufacturer strings</li><li><code>:wrapper</code>: Array type for computations</li><li><code>:functional</code>: Boolean indicating if this architecture matches current system</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">backends = list_host_backend()
x86_config = backends[:x86_64]
println(x86_config[:brand])  # [&quot;Intel(R)&quot;, &quot;AMD&quot;]
println(x86_config[:functional])  # true (on x86-64 systems)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ewyser/UnifiedBackend.jl/blob/6a83ec619b17657f684e20893dc53675fa248a07/src/home/api/backend_setup.jl#L3-L33">source</a></section></details></article><article><details class="docstring"><summary id="UnifiedBackend.list_cpu_devices"><a class="docstring-binding" href="#UnifiedBackend.list_cpu_devices"><code>UnifiedBackend.list_cpu_devices</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">list_cpu_devices() -&gt; Vector{String}</code></pre><p>Get a list of CPU device names from system information.</p><p>Queries <code>Sys.cpu_info()</code> and extracts the model name prefix (before the colon) for each available CPU core. This is used to populate device configurations in the ExecutionPlatforms structure.</p><p><strong>Returns</strong></p><p>Vector of CPU model name strings, one per logical core.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">devices = list_cpu_devices()
println(length(devices))  # Number of logical CPU cores
println(devices[1])       # &quot;Intel(R) Core(TM) i9-9900K CPU @ 3.60GHz&quot;</code></pre><p><strong>See Also</strong></p><ul><li><code>Sys.cpu_info()</code>: Julia&#39;s system CPU information function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ewyser/UnifiedBackend.jl/blob/6a83ec619b17657f684e20893dc53675fa248a07/src/home/api/backend_setup.jl#L59-L83">source</a></section></details></article><h3 id="Device-Management"><a class="docs-heading-anchor" href="#Device-Management">Device Management</a><a id="Device-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Device-Management" title="Permalink"></a></h3><article><details class="docstring"><summary id="UnifiedBackend.device_wakeup!"><a class="docstring-binding" href="#UnifiedBackend.device_wakeup!"><code>UnifiedBackend.device_wakeup!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">device_wakeup!() -&gt; Nothing</code></pre><p>Stub function for activating a specific device.</p><p>This is a placeholder function that must be overloaded by backend extensions (CUDAExt, ROCmExt) to provide device-specific wake-up functionality. Device wake-up typically involves setting the active GPU context for subsequent operations.</p><p><strong>Backend Implementations</strong></p><p>Extensions should implement:</p><ul><li><code>device_wakeup!(::CuDevice)</code> for CUDA GPUs</li><li><code>device_wakeup!(::HIPDevice)</code> for ROCm GPUs</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Will error - stub not overloaded
device_wakeup!()  # ErrorException

# After loading CUDA
using CUDA
gpu = select_execution_backend(backend().exec, &quot;device&quot;)
device_wakeup!(gpu.dev1[:handle])  # Sets active CUDA device</code></pre><p><strong>Errors</strong></p><p>Throws <code>ErrorException</code> if called without backend extension loaded.</p><p><strong>See Also</strong></p><ul><li>Extensions: <code>CUDAExt</code>, <code>ROCmExt</code></li><li>Device selection: <a href="#UnifiedBackend.select_execution_backend"><code>select_execution_backend</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ewyser/UnifiedBackend.jl/blob/6a83ec619b17657f684e20893dc53675fa248a07/src/home/api/device_management.jl#L3-L38">source</a></section></details></article><article><details class="docstring"><summary id="UnifiedBackend.device_free!"><a class="docstring-binding" href="#UnifiedBackend.device_free!"><code>UnifiedBackend.device_free!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">device_free!(mesh, ::Val{:CPU}) -&gt; Nothing</code></pre><p>Free device memory for CPU backend and trigger garbage collection.</p><p>For CPU execution, this function simply calls Julia&#39;s garbage collector to reclaim memory. GPU backend extensions may override this with device-specific memory management.</p><p><strong>Arguments</strong></p><ul><li><code>mesh</code>: Any object whose memory should be freed (typically ignored for CPU)</li><li><code>::Val{:CPU}</code>: Type parameter specifying CPU backend</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Free CPU memory
data = rand(1000, 1000)
device_free!(data, Val(:CPU))
# Triggers GC.gc()

# GPU backends would call device-specific free functions
# device_free!(gpu_data, Val(:CUDA))  # Would call CUDA.unsafe_free!</code></pre><p><strong>Notes</strong></p><p>This is primarily useful for consistency with GPU backends. For CPU-only code, directly calling <code>GC.gc()</code> is equivalent.</p><p><strong>See Also</strong></p><ul><li><code>GC.gc()</code>: Julia&#39;s garbage collector</li><li>Extensions: <code>CUDAExt</code>, <code>ROCmExt</code> (provide GPU-specific implementations)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ewyser/UnifiedBackend.jl/blob/6a83ec619b17657f684e20893dc53675fa248a07/src/home/api/device_management.jl#L43-L78">source</a></section></details></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#UnifiedBackend.Backend"><code>UnifiedBackend.Backend</code></a></li><li><a href="#UnifiedBackend.ExecutionPlatforms"><code>UnifiedBackend.ExecutionPlatforms</code></a></li><li><a href="#UnifiedBackend.add_backend!"><code>UnifiedBackend.add_backend!</code></a></li><li><a href="#UnifiedBackend.backend"><code>UnifiedBackend.backend</code></a></li><li><a href="#UnifiedBackend.device_free!"><code>UnifiedBackend.device_free!</code></a></li><li><a href="#UnifiedBackend.device_wakeup!"><code>UnifiedBackend.device_wakeup!</code></a></li><li><a href="#UnifiedBackend.get_device"><code>UnifiedBackend.get_device</code></a></li><li><a href="#UnifiedBackend.get_host"><code>UnifiedBackend.get_host</code></a></li><li><a href="#UnifiedBackend.list_cpu_devices"><code>UnifiedBackend.list_cpu_devices</code></a></li><li><a href="#UnifiedBackend.list_host_backend"><code>UnifiedBackend.list_host_backend</code></a></li><li><a href="#UnifiedBackend.select_execution_backend"><code>UnifiedBackend.select_execution_backend</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../extensions/">Extensions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 8 February 2026 14:53">Sunday 8 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
